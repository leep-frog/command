package command

import (
	"fmt"
	"sort"
	"strings"
)

// Completion is the object constructed by a completer.
type Completion struct {
	// Suggestions is the set of autocomplete suggestions.
	Suggestions []string
	// IgnoreFilter indicates whether prefixes that don't match should be filtered out or not.
	IgnoreFilter bool
	// DontComplete indicates whether or not we should fill in partial completions.
	// This is achieved by adding a " " suggestion.
	DontComplete bool
	// CaseInsensitiveSort returns whether or not we should sort irrespective of case.
	CaseInsensitiveSort bool
	// CaseInsensitve is whether or not case should be considered when filtering out suggestions.
	CaseInsensitive bool
	// Distinct is whether or not we should return only distinct suggestions (specifically to prevent duplicates in list arguments).
	// Note: this is only applied for built-in types like `Argument` and `Flag`. To ensure
	// distinctness for custom argument processors, you will need to implement
	// logic in those custom objects yourself.
	Distinct bool
	// SpacelessCompletion indicates that a space should *not* be added (which happens
	// automatically if there is only one completion suggestion).
	SpacelessCompletion bool
	// DeferredCompletion will *execute* another graph before generating the actual
	// completion object.
	DeferredCompletion *DeferredCompletion
}

// DeferredCompletion is a Completer that generates a `Completion` object after
// executing a graph.
type DeferredCompletion struct {
	// Graph is the root of a command `Node` graph that will be *execute* (i.e.
	// not completed) before the respective function, `F`, is run. However, the
	// `ExecuteData` generated by executing this graph will be ignored.
	Graph Node
	// F is the function to run after `Graph` has been executed.
	F func(*Completion, *Data) (*Completion, error)
}

func (c *Completion) Clone() *Completion {
	return &Completion{
		c.Suggestions,
		c.IgnoreFilter,
		c.DontComplete,
		c.CaseInsensitiveSort,
		c.CaseInsensitive,
		c.Distinct,
		c.SpacelessCompletion,
		c.DeferredCompletion,
	}
}

// Autocompletion is a subset of the `Completion` type and contains only
// data relevant for the OS package to handle autocompletion logic.
type Autocompletion struct {
	// Suggestions is the set of autocomplete suggestions.
	Suggestions []string
	// SpacelessCompletion indicates that a space should *not* be added (which happens
	// automatically if there is only one completion suggestion).
	SpacelessCompletion bool
}

// ProcessInput processes a `Completion` object against a given `Input` object.
func (c *Completion) ProcessInput(input *Input) []string {
	var lastArg string
	if input != nil && len(input.si.Args) > 0 {
		lastArg = input.si.Args[len(input.si.Args)-1].Value
	}
	return c.Process(lastArg, input.si.Delimiter, false)
}

// process processes a `Completion` object using the provided `lastArg` and `delimiter`.
// If skipDelimiter is true, then no delimiter changes are done.
func (c *Completion) Process(lastArg string, delimiter *rune, skipDelimiter bool) []string {
	results := c.Suggestions

	// Filter out prefixes.
	if !c.IgnoreFilter {
		filterFunc := func(s string) bool { return strings.HasPrefix(s, lastArg) }
		if c.CaseInsensitive {
			lowerLastArg := strings.ToLower(lastArg)
			filterFunc = func(s string) bool { return strings.HasPrefix(strings.ToLower(s), lowerLastArg) }
		}
		var filteredOpts []string
		for _, o := range results {
			if filterFunc(o) {
				filteredOpts = append(filteredOpts, o)
			}
		}
		results = filteredOpts
	}

	if c.CaseInsensitiveSort {
		sort.SliceStable(results, func(i, j int) bool {
			return strings.ToLower(results[i]) < strings.ToLower(results[j])
		})
	} else {
		sort.Strings(results)
	}

	if !skipDelimiter {
		for i, result := range results {
			if strings.Contains(result, " ") {
				if delimiter == nil {
					results[i] = strings.ReplaceAll(result, " ", "\\ ")
				} else {
					results[i] = fmt.Sprintf("%s%s%s", string(*delimiter), result, string(*delimiter))
				}
			}
		}
	}

	if c.DontComplete {
		results = append(results, " ")
	}
	return results
}
